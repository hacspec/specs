(* File automatically generated by Hacspec *)
From Hacspec Require Import Hacspec_Lib MachineIntegers.
From Coq Require Import ZArith.
Import List.ListNotations.
Open Scope Z_scope.
Open Scope bool_scope.

(*Not implemented yet? todo(item)*)

Require Import Hacspec_lib.

Notation State_t := (nseq int32 12).
Definition State : State_t -> State_t :=
  id.

Definition swap (s : t_State_t) (i : uint_size) (j : uint_size) : t_State_t :=
  let tmp := (s.[i]) : t_U32_t in
  let s := (update_at s i (s.[j])) : t_State_t in
  let s := (update_at s j tmp) : t_State_t in
  s.

Definition gimli_round (s : t_State_t) (r : int32) : t_State_t :=
  let s := (fold (into_iter (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 4))) s (fun s col =>
      let x := (rotate_left_under_impl_66 (s.[col]) (@repr WORDSIZE32 24)) : t_U32_t in
      let y := (rotate_left_under_impl_66 (s.[(col.+(@repr WORDSIZE32 4))]) (@repr WORDSIZE32 9)) : t_U32_t in
      let z := (s.[(col.+(@repr WORDSIZE32 8))]) : t_U32_t in
      let s := (update_at s (col.+(@repr WORDSIZE32 8)) ((x.^(z shift_left (@repr WORDSIZE32 1))).^((y.&z) shift_left (@repr WORDSIZE32 2)))) : t_State_t in
      let s := (update_at s (col.+(@repr WORDSIZE32 4)) ((y.^x).^((x.|z) shift_left (@repr WORDSIZE32 1)))) : t_State_t in
      let s := (update_at s col ((z.^y).^((x.&y) shift_left (@repr WORDSIZE32 3)))) : t_State_t in
      s)) : t_State_t in
  let s := (if
      (r.&(@repr WORDSIZE32 3))=.?(@repr WORDSIZE32 0)
    then
      let s := (swap s (@repr WORDSIZE32 0) (@repr WORDSIZE32 1)) : t_State_t in
      let s := (swap s (@repr WORDSIZE32 2) (@repr WORDSIZE32 3)) : t_State_t in
      s
    else
      s) : t_State_t in
  let s := (if
      (r.&(@repr WORDSIZE32 3))=.?(@repr WORDSIZE32 2)
    then
      let s := (swap s (@repr WORDSIZE32 0) (@repr WORDSIZE32 2)) : t_State_t in
      let s := (swap s (@repr WORDSIZE32 1) (@repr WORDSIZE32 3)) : t_State_t in
      s
    else
      s) : t_State_t in
  let s := (if
      (r.&(@repr WORDSIZE32 3))=.?(@repr WORDSIZE32 0)
    then
      update_at s (@repr WORDSIZE32 0) ((s.[(@repr WORDSIZE32 0)]).^((U32 (@repr WORDSIZE32 2654435584)).|(U32 r)))
    else
      s) : t_State_t in
  s.

Definition gimli (s : t_State_t) : t_State_t :=
  let s := (fold (into_iter (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 24))) s (fun s rnd =>
      let rnd := (cast ((@repr WORDSIZE32 24).-rnd)) : int32 in
      let s := (gimli_round s rnd) : t_State_t in
      s)) : t_State_t in
  s.

Notation Block_t := (nseq int8 16).
Definition Block : Block_t -> Block_t :=
  id.

Notation Digest_t := (nseq int8 32).
Definition Digest : Digest_t -> Digest_t :=
  id.

Definition absorb_block (input_block : t_Block_t) (s : t_State_t) : t_State_t :=
  let input_bytes := (to_le_U32s_under_impl_34 input_block) : t_Seq_t t_U32_t in
  let s := (update_at s (@repr WORDSIZE32 0) ((s.[(@repr WORDSIZE32 0)]).^(input_bytes.[(@repr WORDSIZE32 0)]))) : t_State_t in
  let s := (update_at s (@repr WORDSIZE32 1) ((s.[(@repr WORDSIZE32 1)]).^(input_bytes.[(@repr WORDSIZE32 1)]))) : t_State_t in
  let s := (update_at s (@repr WORDSIZE32 2) ((s.[(@repr WORDSIZE32 2)]).^(input_bytes.[(@repr WORDSIZE32 2)]))) : t_State_t in
  let s := (update_at s (@repr WORDSIZE32 3) ((s.[(@repr WORDSIZE32 3)]).^(input_bytes.[(@repr WORDSIZE32 3)]))) : t_State_t in
  gimli s.

Definition squeeze_block (s : t_State_t) : t_Block_t :=
  let block := (new_under_impl_39) : t_Block_t in
  let block := (fold (into_iter (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 4))) block (fun block i =>
      let s_i := (s.[i]) : t_U32_t in
      let s_i_bytes := (to_le_bytes s_i) : t_Seq_t t_U8_t in
      let block := (update_at block ((@repr WORDSIZE32 4).*i) (s_i_bytes.[(@repr WORDSIZE32 0)])) : t_Block_t in
      let block := (update_at block (((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 1)) (s_i_bytes.[(@repr WORDSIZE32 1)])) : t_Block_t in
      let block := (update_at block (((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 2)) (s_i_bytes.[(@repr WORDSIZE32 2)])) : t_Block_t in
      let block := (update_at block (((@repr WORDSIZE32 4).*i).+(@repr WORDSIZE32 3)) (s_i_bytes.[(@repr WORDSIZE32 3)])) : t_Block_t in
      block)) : t_Block_t in
  block.

Definition gimli_hash_state (input : t_Seq_t t_U8_t) (s : t_State_t) : t_State_t :=
  let rate := (length_under_impl_39) : uint_size in
  let chunks := (num_exact_chunks_under_impl_41 input rate) : uint_size in
  let s := (fold (into_iter (Build_Range (@repr WORDSIZE32 0)chunks)) s (fun s i =>
      let input_block := (get_exact_chunk_under_impl_41 input rate i) : t_Seq_t t_U8_t in
      let full_block := (from_seq_under_impl_52 input_block) : t_Block_t in
      let s := (absorb_block full_block s) : t_State_t in
      s)) : t_State_t in
  let input_block := (get_remainder_chunk_under_impl_41 input rate) : t_Seq_t t_U8_t in
  let input_block_padded := (new_under_impl_39) : t_Block_t in
  let input_block_padded := (update_start input_block_padded input_block) : t_Block_t in
  let input_block_padded := (update_at input_block_padded (len_under_impl_41 input_block) (U8 (@repr WORDSIZE8 1))) : t_Block_t in
  let s := (update_at s (@repr WORDSIZE32 11) ((s.[(@repr WORDSIZE32 11)]).^(U32 (@repr WORDSIZE32 16777216)))) : t_State_t in
  let s := (absorb_block input_block_padded s) : t_State_t in
  s.

Definition gimli_hash (input_bytes : t_Seq_t t_U8_t) : t_Digest_t :=
  let s := (new_under_impl_4) : t_State_t in
  let s := (gimli_hash_state input_bytes s) : t_State_t in
  let output := (new_under_impl_74) : t_Digest_t in
  let output := (update_start output (squeeze_block s)) : t_Digest_t in
  let s := (gimli s) : t_State_t in
  update output length_under_impl_39 (squeeze_block s).

Notation Nonce_t := (nseq int8 16).
Definition Nonce : Nonce_t -> Nonce_t :=
  id.

Notation Key_t := (nseq int8 32).
Definition Key : Key_t -> Key_t :=
  id.

Notation Tag_t := (nseq int8 16).
Definition Tag : Tag_t -> Tag_t :=
  id.

Definition process_ad (ad : t_Seq_t t_U8_t) (s : t_State_t) : t_State_t :=
  gimli_hash_state ad s.

Definition process_msg (message : t_Seq_t t_U8_t) (s : t_State_t) : (t_State_t × t_Seq_t t_U8_t) :=
  let ciphertext := (new_under_impl_41 (len_under_impl_41 message)) : t_Seq_t t_U8_t in
  let rate := (length_under_impl_39) : uint_size in
  let num_chunks := (num_exact_chunks_under_impl_41 message rate) : uint_size in
  let '(ciphertext,s) := (fold (into_iter (Build_Range (@repr WORDSIZE32 0)num_chunks)) (ciphertext,s) (fun '(ciphertext,s) i =>
      let key_block := (squeeze_block s) : t_Block_t in
      let msg_block := (get_exact_chunk_under_impl_41 message rate i) : t_Seq_t t_U8_t in
      let msg_block := (from_seq_under_impl_52 msg_block) : t_Block_t in
      let ciphertext := (set_exact_chunk_under_impl_41 ciphertext rate i (msg_block.^key_block)) : t_Seq_t t_U8_t in
      let s := (absorb_block msg_block s) : t_State_t in
      (ciphertext,s))) : (t_Seq_t t_U8_t × t_State_t) in
  let key_block := (squeeze_block s) : t_Block_t in
  let last_block := (get_remainder_chunk_under_impl_41 message rate) : t_Seq_t t_U8_t in
  let block_len := (len_under_impl_41 last_block) : uint_size in
  let msg_block_padded := (new_under_impl_39) : t_Block_t in
  let msg_block_padded := (update_start msg_block_padded last_block) : t_Block_t in
  let ciphertext := (set_chunk_under_impl_41 ciphertext rate num_chunks (slice_range_under_impl_40 (msg_block_padded.^key_block) (Build_Range (@repr WORDSIZE32 0)block_len))) : t_Seq_t t_U8_t in
  let msg_block_padded := (update_at msg_block_padded block_len ((msg_block_padded.[block_len]).^(U8 (@repr WORDSIZE8 1)))) : t_Block_t in
  let s := (update_at s (@repr WORDSIZE32 11) ((s.[(@repr WORDSIZE32 11)]).^(U32 (@repr WORDSIZE32 16777216)))) : t_State_t in
  let s := (absorb_block msg_block_padded s) : t_State_t in
  (s,ciphertext).

Definition process_ct (ciphertext : t_Seq_t t_U8_t) (s : t_State_t) : (t_State_t × t_Seq_t t_U8_t) :=
  let message := (new_under_impl_41 (len_under_impl_41 ciphertext)) : t_Seq_t t_U8_t in
  let rate := (length_under_impl_39) : uint_size in
  let num_chunks := (num_exact_chunks_under_impl_41 ciphertext rate) : uint_size in
  let '(message,s) := (fold (into_iter (Build_Range (@repr WORDSIZE32 0)num_chunks)) (message,s) (fun '(message,s) i =>
      let key_block := (squeeze_block s) : t_Block_t in
      let ct_block := (get_exact_chunk_under_impl_41 ciphertext rate i) : t_Seq_t t_U8_t in
      let ct_block := (from_seq_under_impl_52 ct_block) : t_Block_t in
      let msg_block := (ct_block.^key_block) : _ in
      let message := (set_exact_chunk_under_impl_41 message rate i (ct_block.^key_block)) : t_Seq_t t_U8_t in
      let s := (absorb_block msg_block s) : t_State_t in
      (message,s))) : (t_Seq_t t_U8_t × t_State_t) in
  let key_block := (squeeze_block s) : t_Block_t in
  let ct_final := (get_remainder_chunk_under_impl_41 ciphertext rate) : t_Seq_t t_U8_t in
  let block_len := (len_under_impl_41 ct_final) : uint_size in
  let ct_block_padded := (new_under_impl_39) : t_Block_t in
  let ct_block_padded := (update_start ct_block_padded ct_final) : t_Block_t in
  let msg_block := (ct_block_padded.^key_block) : _ in
  let message := (set_chunk_under_impl_41 message rate num_chunks (slice_range_under_impl_40 msg_block (Build_Range (@repr WORDSIZE32 0)block_len))) : t_Seq_t t_U8_t in
  let msg_block := (from_slice_range_under_impl_40 msg_block (Build_Range (@repr WORDSIZE32 0)block_len)) : t_Block_t in
  let msg_block := (update_at msg_block block_len ((msg_block.[block_len]).^(U8 (@repr WORDSIZE8 1)))) : t_Block_t in
  let s := (update_at s (@repr WORDSIZE32 11) ((s.[(@repr WORDSIZE32 11)]).^(U32 (@repr WORDSIZE32 16777216)))) : t_State_t in
  let s := (absorb_block msg_block s) : t_State_t in
  (s,message).

Definition nonce_to_u32s (nonce : t_Nonce_t) : t_Seq_t t_U32_t :=
  let uints := (new_under_impl_41 (@repr WORDSIZE32 4)) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 0) (v_U32_from_le_bytes (from_slice_range_under_impl_41 nonce (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 4))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 1) (v_U32_from_le_bytes (from_slice_range_under_impl_41 nonce (Build_Range (@repr WORDSIZE32 4)(@repr WORDSIZE32 8))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 2) (v_U32_from_le_bytes (from_slice_range_under_impl_41 nonce (Build_Range (@repr WORDSIZE32 8)(@repr WORDSIZE32 12))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 3) (v_U32_from_le_bytes (from_slice_range_under_impl_41 nonce (Build_Range (@repr WORDSIZE32 12)(@repr WORDSIZE32 16))))) : t_Seq_t t_U32_t in
  uints.

Definition key_to_u32s (key : t_Key_t) : t_Seq_t t_U32_t :=
  let uints := (new_under_impl_41 (@repr WORDSIZE32 8)) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 0) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 0)(@repr WORDSIZE32 4))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 1) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 4)(@repr WORDSIZE32 8))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 2) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 8)(@repr WORDSIZE32 12))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 3) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 12)(@repr WORDSIZE32 16))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 4) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 16)(@repr WORDSIZE32 20))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 5) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 20)(@repr WORDSIZE32 24))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 6) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 24)(@repr WORDSIZE32 28))))) : t_Seq_t t_U32_t in
  let uints := (update_at uints (@repr WORDSIZE32 7) (v_U32_from_le_bytes (from_slice_range_under_impl_41 key (Build_Range (@repr WORDSIZE32 28)(@repr WORDSIZE32 32))))) : t_Seq_t t_U32_t in
  uints.

Definition gimli_aead_encrypt (message : t_Seq_t t_U8_t) (ad : t_Seq_t t_U8_t) (nonce : t_Nonce_t) (key : t_Key_t) : (t_Seq_t t_U8_t × t_Tag_t) :=
  let s := (from_seq_under_impl_17 (concat_under_impl_41 (nonce_to_u32s nonce) (key_to_u32s key))) : t_State_t in
  let s := (gimli s) : t_State_t in
  let s := (process_ad ad s) : t_State_t in
  let '(s,ciphertext) := (process_msg message s) : (t_State_t × t_Seq_t t_U8_t) in
  let tag := (squeeze_block s) : t_Block_t in
  let tag := (from_seq_under_impl_192 tag) : t_Tag_t in
  (ciphertext,tag).

Definition gimli_aead_decrypt (ciphertext : t_Seq_t t_U8_t) (ad : t_Seq_t t_U8_t) (tag : t_Tag_t) (nonce : t_Nonce_t) (key : t_Key_t) : t_Seq_t t_U8_t :=
  let s := (from_seq_under_impl_17 (concat_under_impl_41 (nonce_to_u32s nonce) (key_to_u32s key))) : t_State_t in
  let s := (gimli s) : t_State_t in
  let s := (process_ad ad s) : t_State_t in
  let '(s,message) := (process_ct ciphertext s) : (t_State_t × t_Seq_t t_U8_t) in
  let my_tag := (squeeze_block s) : t_Block_t in
  let my_tag := (from_seq_under_impl_192 my_tag) : t_Tag_t in
  let out := (new_under_impl_41 (@repr WORDSIZE32 0)) : t_Seq_t t_U8_t in
  let out := (if
      equal my_tag tag
    then
      let out := (message) : t_Seq_t t_U8_t in
      out
    else
      out) : t_Seq_t t_U8_t in
  out.
