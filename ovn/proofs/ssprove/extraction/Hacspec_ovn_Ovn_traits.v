(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

From ConCert.Execution Require Import Serializable.
From Hacspec Require Import ConCertLib.

Class t_Z_Field (Self : choice_type) := {
  f_field_type : choice_type ;
    f_field_type_Serializable : Serializable f_field_type;
  f_field_type_t_Serialize :> (t_Serialize f_field_type) ;
  f_field_type_t_Deserial :> (t_Deserial f_field_type) ;
  f_field_type_t_Serial :> (t_Serial f_field_type) ;
  f_field_type_t_Copy :> (t_Copy f_field_type) ;
  f_field_type_t_Clone :> (t_Clone f_field_type) ;
  f_field_type_t_Eq :> (t_Eq f_field_type) ;
  f_field_type_t_PartialEq :> (t_PartialEq f_field_type) ;
  f_field_type_t_Sized :> (t_Sized f_field_type) ;
  f_q : (both f_field_type) ;
  f_random_field_elem : (both int32 -> both f_field_type) ;
  f_field_zero : (both f_field_type) ;
  f_field_one : (both f_field_type) ;
  f_add : (both f_field_type -> both f_field_type -> both f_field_type) ;
  f_sub : (both f_field_type -> both f_field_type -> both f_field_type) ;
  f_mul : (both f_field_type -> both f_field_type -> both f_field_type) ;
}.

Class t_Group (Self : choice_type) `{t_Z_Field} := {
  f_group_type : choice_type ;
    f_group_type_Serializable : Serializable f_group_type;
  f_group_type_t_Serialize :> (t_Serialize f_group_type) ;
  f_group_type_t_Deserial :> (t_Deserial f_group_type) ;
  f_group_type_t_Serial :> (t_Serial f_group_type) ;
  f_group_type_t_Copy :> (t_Copy f_group_type) ;
  f_group_type_t_Clone :> (t_Clone f_group_type) ;
  f_group_type_t_Eq :> (t_Eq f_group_type) ;
  f_group_type_t_PartialEq :> (t_PartialEq f_group_type) ;
  f_group_type_t_Sized :> (t_Sized f_group_type) ;
  f_g : (both f_group_type) ;
  f_g_pow : (both f_field_type -> both f_group_type) ;
  f_pow : (both f_group_type -> both f_field_type -> both f_group_type) ;
  f_group_one : (both f_group_type) ;
  f_prod : (both f_group_type -> both f_group_type -> both f_group_type) ;
  f_inv : (both f_group_type -> both f_group_type) ;
  f_div : (both f_group_type -> both f_group_type -> both f_group_type) ;
  f_hash : (both (t_Vec f_group_type t_Global) -> both f_field_type) ;
}.
