(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_Amount := int64.
Equations f_micro_ccd {L : {fset Location}} {I : Interface} (s : both L I (t_Amount)) : both L I int64 :=
  f_micro_ccd s  :=
    bind_both s (fun x =>
      solve_lift (ret_both x)) : both L I int64.
Fail Next Obligation.
Equations Build_t_Amount {L0 : {fset Location}} {I0 : Interface} {f_micro_ccd : both L0 I0 int64} : both (L0) (I0) (t_Amount) :=
  Build_t_Amount  :=
    bind_both f_micro_ccd (fun f_micro_ccd =>
                             solve_lift (ret_both ((f_micro_ccd) : (t_Amount)))) : both (L0) (I0) (t_Amount).
Fail Next Obligation.

Definition t_Timestamp := int32.
Definition t_BTreeMap (A B : choice_type) (C : vec_typ) := int32.
Equations impl_20__contains_key {L I A B C} (x : both L I (t_BTreeMap A B C)) (y : both L I A) : both L I 'bool :=
  impl_20__contains_key x y := solve_lift ret_both (true : 'bool).
Fail Next Obligation.
Equations f_slot_time {L I A} (x : both L I A) : both L I int64 :=
  f_slot_time x := solve_lift ret_both 3.
Fail Next Obligation.
Definition f_metadata {A} (x : A) := x.
Definition t_Address : choice_type := int64 ∐ int64.
Definition t_AccountAddress : choice_type := int64.
Definition Address_Contract_case (addr : int64) : t_Address := inl addr.
Definition Address_Account_case (addr : t_AccountAddress) : t_Address := inr addr.
Equations f_sender {L I A} (ctx : both L I A) : both L I t_Address :=
  f_sender ctx := solve_lift ret_both (Address_Account_case 0).
Fail Next Obligation.


Definition t_AuctionState : choice_type :=
  ('unit ∐ t_AccountAddress).
Notation "'AuctionState_NotSoldYet_case'" := (inl tt) (at level 100).
Equations AuctionState_NotSoldYet {L : {fset Location}} {I : Interface} : both L I (t_AuctionState) :=
  AuctionState_NotSoldYet  :=
    solve_lift (ret_both (inl (tt : 'unit) : t_AuctionState)) : both L I (t_AuctionState).
Fail Next Obligation.
Notation "'AuctionState_Sold_case' x" := (inr x) (at level 100).
Equations AuctionState_Sold {L : {fset Location}} {I : Interface} (x : both L I (t_AccountAddress)) : both L I (t_AuctionState) :=
  AuctionState_Sold x  :=
    bind_both x (fun x =>
      solve_lift (ret_both (inr x : t_AuctionState))) : both L I (t_AuctionState).
Fail Next Obligation.

Definition t_BidError : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'BidError_ContractSender_case'" := (inl (inl (inl tt))) (at level 100).
Equations BidError_ContractSender {L : {fset Location}} {I : Interface} : both L I (t_BidError) :=
  BidError_ContractSender  :=
    solve_lift (ret_both (inl (inl (inl (tt : 'unit))) : t_BidError)) : both L I (t_BidError).
Fail Next Obligation.
Notation "'BidError_BidTooLow_case'" := (inl (inl (inr tt))) (at level 100).
Equations BidError_BidTooLow {L : {fset Location}} {I : Interface} : both L I (t_BidError) :=
  BidError_BidTooLow  :=
    solve_lift (ret_both (inl (inl (inr (tt : 'unit))) : t_BidError)) : both L I (t_BidError).
Fail Next Obligation.
Notation "'BidError_BidsOverWaitingForAuctionFinalization_case'" := (inl (inr tt)) (at level 100).
Equations BidError_BidsOverWaitingForAuctionFinalization {L : {fset Location}} {I : Interface} : both L I (t_BidError) :=
  BidError_BidsOverWaitingForAuctionFinalization  :=
    solve_lift (ret_both (inl (inr (tt : 'unit)) : t_BidError)) : both L I (t_BidError).
Fail Next Obligation.
Notation "'BidError_AuctionFinalized_case'" := (inr tt) (at level 100).
Equations BidError_AuctionFinalized {L : {fset Location}} {I : Interface} : both L I (t_BidError) :=
  BidError_AuctionFinalized  :=
    solve_lift (ret_both (inr (tt : 'unit) : t_BidError)) : both L I (t_BidError).
Fail Next Obligation.

Definition t_FinalizeError : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'FinalizeError_BidMapError_case'" := (inl (inl tt)) (at level 100).
Equations FinalizeError_BidMapError {L : {fset Location}} {I : Interface} : both L I (t_FinalizeError) :=
  FinalizeError_BidMapError  :=
    solve_lift (ret_both (inl (inl (tt : 'unit)) : t_FinalizeError)) : both L I (t_FinalizeError).
Fail Next Obligation.
Notation "'FinalizeError_AuctionStillActive_case'" := (inl (inr tt)) (at level 100).
Equations FinalizeError_AuctionStillActive {L : {fset Location}} {I : Interface} : both L I (t_FinalizeError) :=
  FinalizeError_AuctionStillActive  :=
    solve_lift (ret_both (inl (inr (tt : 'unit)) : t_FinalizeError)) : both L I (t_FinalizeError).
Fail Next Obligation.
Notation "'FinalizeError_AuctionFinalized_case'" := (inr tt) (at level 100).
Equations FinalizeError_AuctionFinalized {L : {fset Location}} {I : Interface} : both L I (t_FinalizeError) :=
  FinalizeError_AuctionFinalized  :=
    solve_lift (ret_both (inr (tt : 'unit) : t_FinalizeError)) : both L I (t_FinalizeError).
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Definition t_InitParameter : choice_type :=
  (t_Vec (int8) (t_Global) × t_Timestamp).
Equations f_init_parameter_item {L : {fset Location}} {I : Interface} (s : both L I (t_InitParameter)) : both L I (t_Vec (int8) (t_Global)) :=
  f_init_parameter_item s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst x : t_Vec (int8) (t_Global)))) : both L I (t_Vec (int8) (t_Global)).
Fail Next Obligation.
Equations f_init_parameter_expiry {L : {fset Location}} {I : Interface} (s : both L I (t_InitParameter)) : both L I (t_Timestamp) :=
  f_init_parameter_expiry s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_Timestamp))) : both L I (t_Timestamp).
Fail Next Obligation.
Equations Build_t_InitParameter {L0 : {fset Location}} {L1 : {fset Location}} {I0 : Interface} {I1 : Interface} {f_init_parameter_item : both L0 I0 (t_Vec (int8) (t_Global))} {f_init_parameter_expiry : both L1 I1 (t_Timestamp)} : both (L0:|:L1) (I0:|:I1) (t_InitParameter) :=
  Build_t_InitParameter  :=
    bind_both f_init_parameter_expiry (fun f_init_parameter_expiry =>
      bind_both f_init_parameter_item (fun f_init_parameter_item =>
        solve_lift (ret_both ((f_init_parameter_item,f_init_parameter_expiry) : (t_InitParameter))))) : both (L0:|:L1) (I0:|:I1) (t_InitParameter).
Fail Next Obligation.
Notation "'Build_t_InitParameter' '[' x ']' '(' 'f_init_parameter_item' ':=' y ')'" := (Build_t_InitParameter (f_init_parameter_item := y) (f_init_parameter_expiry := f_init_parameter_expiry x)).
Notation "'Build_t_InitParameter' '[' x ']' '(' 'f_init_parameter_expiry' ':=' y ')'" := (Build_t_InitParameter (f_init_parameter_item := f_init_parameter_item x) (f_init_parameter_expiry := y)).

Definition t_State : choice_type :=
  (t_AuctionState × t_Amount × t_Vec (int8) (t_Global) × t_Timestamp × t_BTreeMap (t_AccountAddress) (t_Amount) (t_Global)).
Equations f_auction_state {L : {fset Location}} {I : Interface} (s : both L I (t_State)) : both L I (t_AuctionState) :=
  f_auction_state s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (fst (fst (fst (fst x))) : t_AuctionState))) : both L I (t_AuctionState).
Fail Next Obligation.
Equations f_highest_bid {L : {fset Location}} {I : Interface} (s : both L I (t_State)) : both L I (t_Amount) :=
  f_highest_bid s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst (fst x))) : t_Amount))) : both L I (t_Amount).
Fail Next Obligation.
Equations f_item {L : {fset Location}} {I : Interface} (s : both L I (t_State)) : both L I (t_Vec (int8) (t_Global)) :=
  f_item s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst (fst x)) : t_Vec (int8) (t_Global)))) : both L I (t_Vec (int8) (t_Global)).
Fail Next Obligation.
Equations f_expiry {L : {fset Location}} {I : Interface} (s : both L I (t_State)) : both L I (t_Timestamp) :=
  f_expiry s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd (fst x) : t_Timestamp))) : both L I (t_Timestamp).
Fail Next Obligation.
Equations f_bids {L : {fset Location}} {I : Interface} (s : both L I (t_State)) : both L I (t_BTreeMap (t_AccountAddress) (t_Amount) (t_Global)) :=
  f_bids s  :=
    bind_both s (fun x =>
      solve_lift (ret_both (snd x : t_BTreeMap (t_AccountAddress) (t_Amount) (t_Global)))) : both L I (t_BTreeMap (t_AccountAddress) (t_Amount) (t_Global)).
Fail Next Obligation.
Equations Build_t_State {L0 : {fset Location}} {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {L4 : {fset Location}} {I0 : Interface} {I1 : Interface} {I2 : Interface} {I3 : Interface} {I4 : Interface} {f_auction_state : both L0 I0 (t_AuctionState)} {f_highest_bid : both L1 I1 (t_Amount)} {f_item : both L2 I2 (t_Vec (int8) (t_Global))} {f_expiry : both L3 I3 (t_Timestamp)} {f_bids : both L4 I4 (t_BTreeMap (t_AccountAddress) (t_Amount) (t_Global))} : both (L0:|:L1:|:L2:|:L3:|:L4) (I0:|:I1:|:I2:|:I3:|:I4) (t_State) :=
  Build_t_State  :=
    bind_both f_bids (fun f_bids =>
      bind_both f_expiry (fun f_expiry =>
        bind_both f_item (fun f_item =>
          bind_both f_highest_bid (fun f_highest_bid =>
            bind_both f_auction_state (fun f_auction_state =>
              solve_lift (ret_both ((f_auction_state,f_highest_bid,f_item,f_expiry,f_bids) : (t_State)))))))) : both (L0:|:L1:|:L2:|:L3:|:L4) (I0:|:I1:|:I2:|:I3:|:I4) (t_State).
Fail Next Obligation.
Notation "'Build_t_State' '[' x ']' '(' 'f_auction_state' ':=' y ')'" := (Build_t_State (f_auction_state := y) (f_highest_bid := f_highest_bid x) (f_item := f_item x) (f_expiry := f_expiry x) (f_bids := f_bids x)).
Notation "'Build_t_State' '[' x ']' '(' 'f_highest_bid' ':=' y ')'" := (Build_t_State (f_auction_state := f_auction_state x) (f_highest_bid := y) (f_item := f_item x) (f_expiry := f_expiry x) (f_bids := f_bids x)).
Notation "'Build_t_State' '[' x ']' '(' 'f_item' ':=' y ')'" := (Build_t_State (f_auction_state := f_auction_state x) (f_highest_bid := f_highest_bid x) (f_item := y) (f_expiry := f_expiry x) (f_bids := f_bids x)).
Notation "'Build_t_State' '[' x ']' '(' 'f_expiry' ':=' y ')'" := (Build_t_State (f_auction_state := f_auction_state x) (f_highest_bid := f_highest_bid x) (f_item := f_item x) (f_expiry := y) (f_bids := f_bids x)).
Notation "'Build_t_State' '[' x ']' '(' 'f_bids' ':=' y ')'" := (Build_t_State (f_auction_state := f_auction_state x) (f_highest_bid := f_highest_bid x) (f_item := f_item x) (f_expiry := f_expiry x) (f_bids := y)).
Fail Next Obligation.

Equations auction_bid {L1 : {fset Location}} {L2 : {fset Location}} {L3 : {fset Location}} {I1 : Interface} {I2 : Interface} {I3 : Interface} {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} (ctx : both L1 I1 (impl_574521470_)) (amount : both L2 I2 (t_Amount)) (state : both L3 I3 (t_State)) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_Result ((v_A × t_State)) (t_BidError)) :=
  auction_bid ctx amount state  :=
    solve_lift (run ((* letb slot_time := f_slot_time (f_metadata ctx) in *)
    letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_BidError))] sender_address := matchb f_sender ctx with
    | inl _ =>
      (* letb _ := ret_both tt in *)
      letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_BidError))] hoist1 := v_Break (Result_Err BidError_ContractSender) in
      ControlFlow_Continue (solve_lift (never_to_any hoist1))
    | inr account_address =>
      letb account_address := ret_both ((account_address) : (t_AccountAddress)) in
      ControlFlow_Continue (solve_lift account_address)
    end in
    (* letb (bid_to_update:both _ _ int64) := ifb impl_20__contains_key (f_bids state) sender_address *)
    (* then f_micro_ccd ((f_bids state).a[sender_address]) *)
    (* else ret_both (0 : int64) in *)
    (* letb bid_to_update := bid_to_update .+ (f_micro_ccd amount) in *)
    (* letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_BidError))] _ := ifb negb (bid_to_update >.? (f_micro_ccd (f_highest_bid state))) *)
    (* then letm[choice_typeMonad.result_bind_code (t_Result ((v_A × t_State)) (t_BidError))] hoist2 := v_Break (Result_Err BidError_BidTooLow) in *)
    (* ControlFlow_Continue (never_to_any hoist2) *)
    (* else ControlFlow_Continue (ret_both (tt : 'unit)) in *)
    ControlFlow_Continue (letb state := Build_t_State[state] (f_highest_bid := Build_t_Amount (f_micro_ccd := ret_both 3 (* bid_to_update *))) in
    Result_Ok (prod_b (f_accept (* (ret_both (tt : 'unit)) *),state))))) : both (L1 :|: L2 :|: L3) (I1 :|: I2 :|: I3) (t_Result ((v_A × t_State)) (t_BidError)).
Next Obligation.
  
Fail Next Obligation.

Definition remaining_bid_loc {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} : Location :=
  (t_Option ((t_AccountAddress × t_Amount));0%nat).
Definition return_action_loc {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} : Location :=
  (v_A;1%nat).
Equations auction_finalize {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} (ctx : both L1 I1 (impl_574521470_)) (state : both L2 I2 (t_State)) : both (L1 :|: L2 :|: fset [remaining_bid_loc;return_action_loc]) (I1 :|: I2) ((t_State × t_Result (v_A) (t_FinalizeError))) :=
  auction_finalize ctx state  :=
    solve_lift (run (letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] _ := ifb not ((f_auction_state state) =.? AuctionState_NotSoldYet)
    then letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] hoist3 := v_Break (prod_b (state,Result_Err FinalizeError_AuctionFinalized)) in
    ControlFlow_Continue (never_to_any hoist3)
    else ControlFlow_Continue (ret_both (tt : 'unit)) in
    letb slot_time := f_slot_time (f_metadata ctx) in
    letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] _ := ifb not (slot_time >.? (f_expiry state))
    then letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] hoist4 := v_Break (prod_b (state,Result_Err FinalizeError_AuctionStillActive)) in
    ControlFlow_Continue (never_to_any hoist4)
    else ControlFlow_Continue (ret_both (tt : 'unit)) in
    letb owner := f_owner ctx in
    letb balance := f_self_balance ctx in
    letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] '(state,hax_temp_output) := ifb balance =.? (impl__Amount__zero (ret_both (tt : 'unit)))
    then ControlFlow_Continue (prod_b (state,Result_Ok (f_accept (ret_both (tt : 'unit)))))
    else letb return_action loc(return_action_loc) := f_simple_transfer owner (f_highest_bid state) in
    letb remaining_bid loc(remaining_bid_loc) := Option_None in
    letb '(remaining_bid,return_action,state) := foldi_both_list (f_into_iter (impl_91__iter (f_bids state))) (fun '(addr,amnt) =>
      ssp (fun '(remaining_bid,return_action,state) =>
        solve_lift (ifb amnt <.? (f_highest_bid state)
        then ControlFlow_Continue (letb return_action := f_and_then return_action (f_simple_transfer addr amnt) in
        prod_b (remaining_bid,return_action,state))
        else letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] _ := ifb not (impl__is_none remaining_bid)
        then letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] hoist5 := v_Break (prod_b (state,Result_Err FinalizeError_BidMapError)) in
        ControlFlow_Continue (never_to_any hoist5)
        else ControlFlow_Continue (ret_both (tt : 'unit)) in
        ControlFlow_Continue (letb state := Build_t_State[state] (f_auction_state := AuctionState_Sold addr) in
        letb remaining_bid := Option_Some (prod_b (addr,amnt)) in
        prod_b (remaining_bid,return_action,state))) : both (*4*)(L1:|:L2:|:L2:|:L1:|:L2:|:fset [remaining_bid_loc;return_action_loc;remaining_bid_loc;return_action_loc]) (I1:|:I2:|:I2:|:I1:|:I2) (t_ControlFlow ((t_State × t_Result (v_A) (t_FinalizeError))) ((t_Option ((t_AccountAddress × t_Amount)) × v_A × t_State))))) (prod_b (remaining_bid,return_action,state)) in
    matchb remaining_bid with
    | Option_Some_case (_,amount) =>
      letb amount := ret_both (((amount)) : ((t_AccountAddress × t_Amount))) in
      letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] _ := ifb not (amount =.? (f_highest_bid state))
      then letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] hoist6 := v_Break (prod_b (state,Result_Err FinalizeError_BidMapError)) in
      ControlFlow_Continue (never_to_any hoist6)
      else ControlFlow_Continue (ret_both (tt : 'unit)) in
      ControlFlow_Continue (solve_lift (prod_b (state,Result_Ok return_action)))
    | Option_None_case  =>
      letm[choice_typeMonad.result_bind_code ((t_State × t_Result (v_A) (t_FinalizeError)))] hoist7 := v_Break (prod_b (state,Result_Err FinalizeError_BidMapError)) in
      ControlFlow_Continue (solve_lift (prod_b (state,never_to_any hoist7)))
    end in
    ControlFlow_Continue (prod_b (state,hax_temp_output)))) : both (L1 :|: L2 :|: fset [remaining_bid_loc;return_action_loc]) (I1 :|: I2) ((t_State × t_Result (v_A) (t_FinalizeError))).
Fail Next Obligation.

Equations fresh_state {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} (itm : both L1 I1 (t_Vec (int8) (t_Global))) (exp : both L2 I2 (t_Timestamp)) : both (L1 :|: L2) (I1 :|: I2) (t_State) :=
  fresh_state itm exp  :=
    solve_lift (Build_t_State (f_auction_state := AuctionState_NotSoldYet) (f_highest_bid := impl__Amount__zero (ret_both (tt : 'unit))) (f_item := itm) (f_expiry := exp) (f_bids := impl_18__new (ret_both (tt : 'unit)))) : both (L1 :|: L2) (I1 :|: I2) (t_State).
Fail Next Obligation.

Equations auction_init {L1 : {fset Location}} {I1 : Interface} {impl_108907986_ : _} `{ t_Sized (impl_108907986_)} `{ t_HasInitContext (impl_108907986_) ('unit)} (ctx : both L1 I1 (impl_108907986_)) : both L1 I1 (t_Result (t_State) (t_Reject)) :=
  auction_init ctx  :=
    solve_lift (run (letb '(_,out) := f_get (f_parameter_cursor ctx) in
    letm[choice_typeMonad.result_bind_code (t_Result (t_State) (t_Reject))] (parameter:t_InitParameter) := matchb f_branch out with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result (t_Infallible) (t_ParseError))) in
      letm[choice_typeMonad.result_bind_code (t_Result (t_State) (t_Reject))] hoist8 := v_Break (f_from_residual residual) in
      ControlFlow_Continue (solve_lift (never_to_any hoist8))
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_InitParameter)) in
      ControlFlow_Continue (solve_lift val)
    end in
    ControlFlow_Continue (Result_Ok (fresh_state (f_init_parameter_item parameter) (f_init_parameter_expiry parameter))))) : both L1 I1 (t_Result (t_State) (t_Reject)).
Fail Next Obligation.

(** Concert lib part **)
From ConCert.Utils Require Import Extras.
Export Extras.
From ConCert.Utils Require Import Automation.
Export Automation.
From ConCert.Execution Require Import Serializable.
Export Serializable.
From ConCert.Execution Require Import Blockchain.
Export Blockchain.
From ConCert.Execution Require Import ContractCommon.
Export ContractCommon.
From ConCert.Execution Require Import Serializable.
Export Serializable.
Require Import ConCertLib.
Export ConCertLib.

Definition state_auction : choice_type :=
  t_State.

Definition receive_auction_bid {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} {L0 : {fset Location}} {I0 : Interface} (st : both L0 I0 (state_auction)) : both _ _ (t_Result ((v_A × state_auction)) (t_ParseError)) :=
  auction_bid st.

Definition receive_auction_finalize {v_A : _} {impl_574521470_ : _} `{ t_Sized (v_A)} `{ t_Sized (impl_574521470_)} `{ t_HasActions (v_A)} `{ t_HasReceiveContext (impl_574521470_) ('unit)} {L0 : {fset Location}} {I0 : Interface} (st : both L0 I0 (state_auction)) : both _ _ (t_Result ((v_A × state_auction)) (t_ParseError)) :=
  auction_finalize st.

Definition init_auction (chain : Chain) (ctx : ContractCallContext) (st : state_auction) : ResultMonad.result (state_auction) (t_ParseError) :=
  ResultMonad.Ok st.

Inductive Msg_auction: Type :=
| msg_auction_bid : Msg_auction
| msg_auction_finalize : Msg_auction.
#[global] Program Instance state_auction_t_HasReceiveContext : t_HasReceiveContext state_auction 'unit :=
  {| f_get := (fun  (Ctx : _) {L : {fset Location}} {I : Interface} => (solve_lift (@ret_both (t_ParamType × t_Result Ctx t_ParseError)) (tt, inr tt)) : _)|}.
Fail Next Obligation.
#[global] Program Instance state_auction_t_Sized : t_Sized state_auction :=
  fun x =>
    x.
Fail Next Obligation.
#[global] Program Instance state_auction_t_HasActions : t_HasActions state_auction :=
  Admitted.
Fail Next Obligation.
Equations receive_auction (chain : Chain) (ctx : ContractCallContext) (st : state_auction) (msg : Datatypes.option Msg_auction) : ResultMonad.result (state_auction * list ActionBody) t_ParseError :=
  receive_auction chain ctx st msg  :=
    match msg with
    | Some msg_auction_bid =>
      match (is_pure (both_prog (receive_auction_bid (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | Some msg_auction_finalize =>
      match (is_pure (both_prog (receive_auction_finalize (ret_both st)))) with
         | inl x => ResultMonad.Ok ((fst x), [])
         | inr x => ResultMonad.Err x
         end
    | _ =>
      ResultMonad.Err tt
    end : ResultMonad.result (state_auction * list ActionBody) t_ParseError.
Fail Next Obligation.
#[global] Program Instance state_auction_Serializable : Serializable state_auction :=
  _.
Fail Next Obligation.
#[global] Program Instance Msg_auction_Serializable : Serializable Msg_auction :=
  Derive Serializable Msg_OVN_rect<msg_auction_bid,msg_auction_finalize>.
Fail Next Obligation.
Definition contract_auction : Contract (state_auction) (Msg_auction) (state_auction) (t_ParseError) :=
  build_contract init_auction receive_auction.
